1. OOP(Object Oriented Programming)
'객체 지향'은 객체를 중심으로 실세계(또는 그 외 어떤 것들)를 바라보는 관점이다. 
그러므로 '객체 지향 프로그래밍'은 객체를 중심으로 프로그래밍을 하겠다는 방법론이다.
현실 세계를 구성하는 모든 요소(사람, 사물, 개념 등)를 각각의 객체로 볼 수 있으며, 
이를 컴퓨터에 그대로 옮겨서 프로그래밍화 하면 바로 OOP인 것이다.
------------------------------------------------------------------------------------------------------------------------------------------------------
2. Object(객체)
현실 세계를 구성하는 모든 요소는 객체라고 볼 수 있다. 
즉, 사람/사물/개념 등 무엇이든 객체일 수 있다.

각 객체는 식별성을 가지며, 행위를 통해 상태가 변한다. 
다만, 시간과 같이 행위 없이 상태가 변하는 경우도 있다.
예를 들면 '홍길동'이라는 식별성을 가진 객체는 '공부'라는 행위를 통해 성적의 상태가 C+에서 A+로 변했다.
한편, '홍길동'은 아무 행위 없이도 계속 늙어가고있다.

이 개념을 프로그래밍에 그대로 옮겼을 때, Class를 기반으로 실제로 구현하려는 대상이 객체에 해당한다. 

실제로 구현한 객체는 인스턴스라고 부른다.
OOP의 객체도 마찬가지로 식별성, 행위, 상태를 가지지만
실세계의 객체와 달리 스스로 상태를 바꿀 수도 있는 '자율성'을 가진 존재다. 
------------------------------------------------------------------------------------------------------------------------------------------------------
3. Class
객체를 생성하기 위한 템플릿이다. 속성을 나타내는 필드, 기능을 나타내는 메서드를 통해 만들어질 객체의 구성요소를 표현해준다. 비슷한 특징을 가진 객체를 여러 개 만들기 위해서 그 특징들을 Classification해둔다. 이후 new 키워드를 통해 객체를 생성하며(인스턴스화), 클래스와 동일한 이름의 메서드인 Constructor(생성자)를 통해 인스턴스값을 초기화 할 수 있다. Class라는 개념을 통해 캡슐화, 상속, 다형성의 개념이 파생된다.
------------------------------------------------------------------------------------------------------------------------------------------------------
4. Abstraction(추상화)
구체적인 내용보다는, 러프하고 특징적이고 공통적인 것에 이름을 붙이는 것이다.
예를 들면 디렉토리명이 있다. 디렉토리 내부의 구체적인 내용은 정의하지 않더라도, 대충 어떤 내용이 들어갈 디렉토리인지 파악할 수 있다. 
------------------------------------------------------------------------------------------------------------------------------------------------------
5. Generalization(일반화)/Inheritance(상속)

일반화는 객체들의 공통점을 개념적으로 묶은 것이다. 예를 들면 여학생과 남학생 각각은 '학생'으로 일반화 할 수 있다.

여학생과 남학생이라는 구체적인 객체를 학생으로 일반화 하였으므로 하위->상위로 추려지는 느낌이 있다. 

그래서 widening이나 up-casting으로 불리기도 한다.

이러한 구조는 클래스 간의 관계로서 생각할 수도 있으며 '일반화 관계'라고 부른다.



반면, 상속에서 하위 클래스는 일반화된 상위 클래스를 상속받음으로써 공통적인 속성과 기능을 그대로 받게된다. 

이후 자신만의 구체화 된 특징들을 정의하면 된다. 그러므로 일반화와 비슷하지만 상위->하위로 물려지는 느낌이 있다.

'일반화 관계'와 마찬가지로 '상속 관계'라는 클래스 간의 관계 표현 관점으로도 볼 수 있다.



상속을 통해 공통적인 코드를 중복 작성하지 않아도 되므로 간결한 코드를 통한 효과(가독성, 생산성, 에러 감소..)를 얻을 수 있다. 또한, 코드의 재사용성이 증가하므로 효율적이다.   
------------------------------------------------------------------------------------------------------------------------------------------------------
6. Specialization

상위 클래스를 상속 및 확장함으로써 General한 클래스를 Specific한 클래스로 생성하는 것이다.

상위 클래스로부터 하위 클래스로 확장하는 것이므로 narrowing이나 down-casting으로 불리기도 한다.

------------------------------------------------------------------------------------------------------------------------------------------------------
7. Realization
인터페이스는 모든 메서드의 내부를 구체적으로 정의하지 않고, 어떤 기능들이 필요할 것이라는 틀만 선언한 것이다. 

추상클래스는 추상 메서드를 1개라도 포함하는 클래스이며, 추상 메서드는 인터페이스와 마찬가지로 내부 구현이 없고 선언만 있는 메서드이다.



Realization은 그 중 인터페이스를 실제 구현한 개념이다. 예를 들면 '날 수 있는 것'의 Realization은 비행기, 새 등이 된다.

그 과정에서 비행기나 새가 구체적으로 어떻게 나는지 각각 메서드를 실제 구현 했을 것이다.

이 개념 또한 클래스 간의 관계로서 생각한다면 '실체화 관계'라고 부른다.



실체화 관계는 상속 관계와 비슷하지만 차이가 있다.

실체화 관계는 (인터페이스&인터페이스를 실제 구현한 것)을 나타내기 때문이다.

추상 클래스는 이미 구현된 일반 메서드 역시 가지고 있는데, 이러한 상속 관계는 상위 클래스를 하위 클래스에 extends하는 것이므로 상위의 구현이 바뀌면 하위에서 영향을 받는다.

그러나 실체화 관계는 인터페이스를 하위 클래스가 implements한 것이므로 영향이나 파급 효과가 적다. 또한, 이처럼 서로 영향력이나 의존성이 적을 때 결합도가 낮다고 표현한다. 

------------------------------------------------------------------------------------------------------------------------------------------------------
8. Association
OOP는 객체 중심, 객체들이 통신하며 프로세스를 진행한다. 그러므로 각 클래스간의 관계를 정의할 필요가 있다. 

클래스의 관계는 크게 Association, Aggregation, Composition, Dependency는 물론 앞서 설명한 실체화 관계 등 여러 가지가 있다. 



그 중 Association은 한 클래스가 다른 클래스의 객체를 가지고 있는(연관이 있는) 경우이다.

예를 들어, '학생'이란 클래스와 '과목'이란 클래스에서 학생은 과목을 수강하므로 과목 객체를 가지고 있을 것이다.

즉, 이 두 클래스는 Association관계이다. 학생 클래스 내에서 과목 인스턴스를 만들어 자유롭게 활용하며, 특히 이는 일시적인 관계가 아니라 쭉 이어지는 관계라는 특징이 있다.

------------------------------------------------------------------------------------------------------------------------------------------------------
9. Dependency

의존적인 클래스 관계를 표현한다. Association과 달리, 다른 클래스를 일시적으로만 참조한다.

가령, 수강정보를 조회할 때만 학생 클래스에서 과목 클래스를 잠깐 참조하는 것이다. (그 외에는 학생에게 과목이 필요한 일이 없을 때)



이 모든 클래스 관계들은 UML의 클래스 다이어그램을 통해 표현할 수 있다. 이를 통해 Dependency와 같은 관계성을 명확히 파악할 수 있다. 예를 들면 Cyclic Dependency(싸이클을 그리며 서로 계속 의존하는 상황)등 골치 아픈 문제를 발견하는 데 유리하다고 한다.

------------------------------------------------------------------------------------------------------------------------------------------------------
10. Polymorphism(다형성)
클래스의 기능이 목적에 따라 여러가지 형태를 띌 수 있는 것이다. 객체지향에서는 클래스의 메서드 오버라이딩이나 오버로딩을 통해 다형성을 구현할 수 있다.



오버라이딩은 부모 클래스를 상속해 그 메서드를 자식 클래스에서 재정의 하는 것이며, 자식만의 기능도 추가할 수 있다.  즉, 자식이 부모의 메서드를 재사용함으로써 시간과 비용을 절약하는 동시에, 자식 클래스의 독자적이고 다른 모습도 보여줄 수 있는 것이다. 

오버로딩은 메서드의 이름은 같게, 매개변수의 개수나 타입은 다르게 정의한다. 메서드들이 같은 기능을 하는데 매개변수만 다를 때 용이하다. 오버로딩이 없다면 단순히 print를 하는 메서드도 printInt, printDouble등 각각 이름을 다르게 정의해야 할 것이다. 또한, default생성자 외에 매개변수를 달리해서 생성자를 여러개 만들어야 하는 경우에도 곤란함이 있을 것이다. 



이처럼 객체지향에서 메서드가 같은 기능을 하더라도 용도에 따라 여러 형태로 나타나는 것을 Polymorphism이라고 한다.

------------------------------------------------------------------------------------------------------------------------------------------------------
11. Encapsulation(캡슐화)/절차은닉/정보은닉


'데이터'와 '데이터를 활용하는 함수'를 캡슐(Class) 안에 함께 넣어 잘 정리하는 방법론이다.(구조화)
즉, 캡슐화를 하면 서로 연관된 데이터와 함수가 Class로 묶이게 된다. 그래서 Bundling이라고 부르기도 한다.

이 방법으로써 캡슐의 내부/외부가 구별지어지며, 캡슐 내부의 데이터와 메서드를 캡슐 외부에 보이게 할지/숨길지 선택할 수 있다. (접근 제한자로 공개 범위 설정)
이처럼 캡슐 내부 요소 중 숨기고 싶은 부분을 은닉하여 보안성을 향상하는 것을 정보은닉이라고 한다. 

캡슐화를 통해 정보 은닉이 일어나므로, 캡슐화와 은닉은 동일한 개념은 아니라고 생각한다.


절차 은닉에 대해서는 정보가 적어 잘 모르겠지만, 알고리즘과 같은 절차/매커니즘을 숨긴다는 의미가 아닐까 생각한다.
그 알고리즘은 절차지향 언어에서 의미하는 '프로그램 전체'의 순서와 흐름(절차)의 개념을 '객체 하나'에 적용해 본 관점일 수도 있을 것 같다.